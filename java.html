<!doctype html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-width=1.0">
	<meta name="author" content="Sunny Beta">
	<meta name="description" content="Software Engineering Notes by Sunny Beta">
	<title>SDE Notes | Java</title>
	<link rel="stylesheet" href="style.css" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</head>

<body>

<div class="container">
	<main>
		<h1>Java</h1>

		<details>
			<summary>Marker Interface</summary>
			<p>
			A <strong>Marker Interface</strong> and <strong>Tagging Interface</strong> is an interface which has no methods or constants inside it. It's job is to provide runtime type information about objects. The <code>Sizeable</code>, <code>Cloneable</code> and <code>Remote</code> interfaces are examples of built-in Java marker interfaces.
			</p>
			<pre><code class="language-java">public class Main{
    public static void main(String[] args){
        Hello hello = new Hello();
        Bye bye = new Bye();
        if (!(hello instanceof Greeting)) System.out.println("Hello is not a greeting.");
        else System.out.println("Hello is a greeting");
        if (!(bye instanceof Greeting)) System.out.println("Bye is not a greeting");
        else System.out.println("Bye is a greeting");
    }
}

public interface Greeting {
}

public class Hello implements Greeting {
    public Hello() {}
}

public class Bye{
    public Bye() {}
}</code></pre>
		</details>

		<details>
			<summary>Serialization vs Deserializatioation</summary>
			<p>
				<strong>Serialization</strong> is the concept of convert an object or data into a byte stream. This byte stream can now be used to write the data to a file or send the data over a network.
				<br/>
				<strong>Deserialization</strong> is converting the byte stream back to its corresponding object or data, for instance, while reading a file and receiving data from a server.
			</p>
		</details>

		<details>
			<summary>Daemon Thread</summary>
			<p>
			A <em>daemon thread</em> is a low-priority thread that runs in the background providing service to user threads.
			The life of a daemon thread depends on the main thread. JVM terminates the daemon thread once the main thread completes its execution.
			The main thread is always a non-daemon thread. For other threads, the daemonic nature is inherited from their parent thread.
			</p>
			<pre><code>// Daemonic Thread
public class Main {
  public static void main(String[] args) {
    Daemon thread1 = new Daemon("thread1");
    Daemon thread2 = new Daemon("thread2");
    Daemon thread3 = new Daemon("thread3");

    thread1.setDaemon(true);

    thread1.start();
    thread2.start();

    thread3.setDaemon(true);
    thread3.start();
  }
}

public class Daemon extends Thread {
  public Daemon(String name) {
    super(name);
  }

  public void run() {
    if(Thread.currentThread().isDaemon()) {
      System.out.println(getName() + " is Daemon Thread");
    } else {
      System.out.println(getName() + " is not Daemon Thread");
    }
  }
}</code></pre>
		</details>

		<h2>FAQ</h2>
		<details class='faq'>
			<summary>Which one will you use for storing passwords: <code>String</code> vs <code>char[]</code></summary>
			<p class='answer'>
				We should use character arrays for storing passwords and other secrets for the following reasons:
				<br/>
				<ul>
					<li><strong>String Immutability.</strong> Strings are immutable, once created this will be accessible until Java's garbage collection clears the unsed objects in memory.</li>
					<li><strong>Prolonged Existence in Heap.</strong>String reference is created in the stack memory and a string object is created in the heap with the intention of reuseability which then lets thestring remain in memory for a longer period of time.</li>
					<li><strong>Logging Risk.</strong> We might log the password (as part of another object) unintentionally to another devce.</li>
				</ul>
			</p>
		</details>

		<details class='faq'>
			<summary>What is the default capacity of an <code>ArrayList</code>?</summary>
			<p class='answer'>
				10
			</p>
		</details>

		<details class='faq'>
			<summary>Why can't we use primitive data types while creating a <code>HashMap</code>?</summary>
			<p>

			</p>
		</details>

		<details class='faq'>
			<summary>Can we have a standalone <code>try</code> block in Java?</summary>
			<p>
			No. We must have a <code>catch</code> or a <code>finally</code> block along with the <code>try</code> block.
			</p>
		</details>

			<li>Composition vs Aggergation</li>
			<li>Queue: poll vs remove</li>
			<li>Streams vs Collections</li>
			<li>ArrayList vs Vectors</li>
			<li>ArrayList vs LinkedList</li>
			<li>Permgen vs Metaspace</li>
			<li>How to handle exceptions in Java?</li>
			<li>Can i have multiple catch blocks?</li>
			<li>StringBuffer vs StringBuilder</li>
			<li>How to compare strings in Java?</li>
			<li>Transient Variable and Non-serializability</li>
			<li>Types of Interfaces: Functional, Default Function, Static Methods</li>
			<li>Internal working of HashMap</li>
			<li>Comparator vs Comparable</li>
			<li>How do you create annotation?</li>
			<li>Immutability of Array.asList()</li>
			<li>FailSafe vs FailFast</li>
			<li>CopyonWriteArrayList</li>
	</main>
</div>

</body>

</html>
